// Code generated by goctl. DO NOT EDIT.
package types

import (
	"fmt"
	jsoniter "github.com/json-iterator/go"
	"github.com/zeromicro/go-zero/rest"
	"github.com/zeromicro/go-zero/rest/httpx"
	"net/http"
	"reflect"
	"strings"
)

type Null struct{}
type metadataItem struct {
	Struct any    `json:"exp"`
	Desc   any    `json:"desc"`
}
var metadataMap = map[string]*struct{
    hasValue bool
	Desc     string `json:"desc"`
	Uri      string `json:"uri"`
    Method   string `json:"method"`
	Req    metadataItem `json:"req"`
    Res    metadataItem `json:"res"`

}{
    {{.metadata}}
}

func RecursiveStruct2Json(obj interface{}, depth, maxDepth int) any {
	if depth > maxDepth { // 最大递归深度为10
		return nil
	}
	val := reflect.ValueOf(obj)
	tvl := reflect.TypeOf(obj)
	if val.Kind() == reflect.Ptr {
		val = val.Elem()
		tvl = tvl.Elem()
	}
	if val.Kind() != reflect.Struct {
		return nil
	}
	var rt = map[string]any{}
	for i := 0; i < val.NumField(); i++ {
		json := tvl.Field(i).Tag.Get("json")
		if json == "-" {
			continue
		}
		if json == "" {
			json = tvl.Field(i).Name
		}
		json = strings.Split(json, ",")[0]
		field := val.Field(i)
		switch field.Kind() {
		case reflect.Slice:
			elemType := field.Type().Elem()
			sli := make([]any, 1)
			if elemType.Kind() == reflect.Ptr && elemType.Elem().Kind() == reflect.Struct {
				// 元素类型为指向结构体的指针
				newVal := reflect.New(elemType.Elem())
				sli[0] = RecursiveStruct2Json(newVal.Interface(), depth+1, maxDepth)
			} else if elemType.Kind() == reflect.Struct {
				newVal := reflect.New(elemType)
				sli[0] = RecursiveStruct2Json(newVal.Interface(), depth+1, maxDepth)
			} else {
				sli[0] = elemType.String()
			}
			rt[json] = sli
		case reflect.Ptr:
			if field.Type().Elem().Kind() != reflect.Struct {
				rt[json] = field.Type().String()
			} else {
				newVal := reflect.New(field.Type().Elem())
				rt[json] = RecursiveStruct2Json(newVal.Interface(), depth+1, maxDepth)
			}
		case reflect.Map:
			rt[json] = RecursiveStruct2Json(reflect.MakeMap(field.Type()), depth+1, maxDepth)
		case reflect.Struct:
			if tvl.Field(i).Anonymous {
				var struc = RecursiveStruct2Json(field.Addr().Interface(), depth+1, maxDepth)
				for k, v := range struc.(map[string]any) {
					rt[k] = v
				}
			} else {
				rt[json] = RecursiveStruct2Json(field.Addr().Interface(), depth+1, maxDepth)
			}
		default:
			rt[json] = tvl.Field(i).Type.String()
		}
	}
	return rt
}

func recursiveInitStruct(obj interface{}, depth, maxDepth int) {
	if depth > maxDepth { // 最大递归深度为10
		return
	}

	val := reflect.ValueOf(obj)
	if val.Kind() != reflect.Ptr {
		return
	}

	val = val.Elem()
	if val.Kind() != reflect.Struct {
		return
	}

	for i := 0; i < val.NumField(); i++ {
		field := val.Field(i)
		switch field.Kind() {
		case reflect.Slice:
			elemType := field.Type().Elem()
			field.Set(reflect.MakeSlice(field.Type(), 1, 1))
			if elemType.Kind() == reflect.Ptr && elemType.Elem().Kind() == reflect.Struct {
				// 元素类型为指向结构体的指针
				newVal := reflect.New(elemType.Elem())
				field.Index(0).Set(newVal)
				recursiveInitStruct(newVal.Interface(), depth+1, maxDepth)
			} else if elemType.Kind() == reflect.Struct {
				recursiveInitStruct(field.Index(0).Addr().Interface(), depth+1, maxDepth)
			}
		case reflect.Ptr:
		    if field.Type().Elem().Kind() <= reflect.Float64 || field.Type().Elem().Kind() == reflect.String || field.Type().Elem().Kind() == reflect.Interface {
        		continue
        	}
			newVal := reflect.New(field.Type().Elem())
			field.Set(newVal)
			recursiveInitStruct(newVal.Interface(), depth+1, maxDepth)
		case reflect.Map:
			field.Set(reflect.MakeMap(field.Type()))
		case reflect.Struct:
			recursiveInitStruct(field.Addr().Interface(), depth+1, maxDepth)
		}
	}
}

func MateDataRoute() rest.Route {
	return rest.Route{
		Method: "GET",
		Path:   "/json/metadata",
		Handler: func(writer http.ResponseWriter, request *http.Request) {
			op := request.URL.Query().Get("op")
			cur, ok := metadataMap[op]
			if !ok && op != "" {
				writer.WriteHeader(404)
				return
			}
			var b []byte
			if ok {
				if !cur.hasValue {
					//	cur.Res.Desc = fmt.Sprintf("%#v", cur.Res.Struct)
					//  cur.Req.Desc = fmt.Sprintf("%#v", cur.Req.Struct)
					cur.Res.Desc = RecursiveStruct2Json(cur.Res.Struct, 0, 5)
					cur.Req.Desc = RecursiveStruct2Json(cur.Req.Struct, 0, 5)
					recursiveInitStruct(cur.Res.Struct, 0, 5)
					recursiveInitStruct(cur.Req.Struct, 0, 5)
					cur.hasValue = true
				}
				b, _ = jsoniter.Marshal(cur)
			} else {
				type oplist struct {
					Desc string `json:"desc"`
					Op   string `json:"op"`
					Uri  string `json:"Uri"`
				}
				actList := make([]oplist, 0, len(metadataMap))
				for k, r := range metadataMap {
					actList = append(actList, oplist{Desc: r.Desc, Uri: fmt.Sprintf("%s?op=%s", request.URL.Path, k), Op: k})
				}
				b, _ = jsoniter.ConfigCompatibleWithStandardLibrary.Marshal(actList)
			}
			_, _ = writer.Write(b)
			writer.Header().Set(httpx.ContentType, httpx.JsonContentType)
			httpx.Ok(writer)
		},
	}
}
